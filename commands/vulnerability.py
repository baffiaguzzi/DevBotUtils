import os
import requests
import glob
from urllib.parse import urljoin
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes, Application
from urllib.parse import urlparse
from datetime import datetime
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from .log_utils import append_log_entry


scheduler = AsyncIOScheduler()

keyboard = [
    [InlineKeyboardButton("SQL Injection", callback_data='deep_sql_injection')],
    [InlineKeyboardButton("Command Injection", callback_data='deep_command_injection')],
    [InlineKeyboardButton("Open Redirect", callback_data='deep_open_redirect')],
]

reply_markup = InlineKeyboardMarkup(keyboard)


def check_sql_injection(url):
    payload = "' OR '1'='1"
    test_url = f"{url}?id={payload}"
    try:
        res = requests.get(test_url, timeout=5)
        if any(keyword in res.text.lower() for keyword in ['sql', 'syntax', 'mysql', 'error', 'warning']):
            return "‚ö†Ô∏è Potenziale SQL Injection rilevata!"
    except Exception as e:
        return f"‚ùå Errore durante test SQLi: {e}!"
    return "‚úÖ Nessuna SQL Injection rilevata."


def check_directory_traversal(url):
    payload = "../../../../../../etc/passwd"
    test_url = f"{url}?file={payload}"
    try:
        res = requests.get(test_url, timeout=5)
        if "root:x:" in res.text:
            return "‚ö†Ô∏è Potenziale Directory Traversal rilevata!"
    except Exception as e:
        return f"‚ùå Errore durante test Directory Traversal: {e}!"
    return "‚úÖ Nessun Directory Traversal rilevato."


def check_lfi(url):
    payload = "../../../../../etc/hosts"
    test_url = f"{url}?page={payload}"
    try:
        res = requests.get(test_url, timeout=5)
        if "localhost" in res.text:
            return "‚ö†Ô∏è Potenziale Local File Inclusion rilevata!"
    except Exception as e:
        return f"‚ùå Errore durante test LFI: {e}!"
    return "‚úÖ Nessuna LFI rilevata."


def check_rfi(url):
    payload = "http://example.com/malicious.txt"
    test_url = f"{url}?page={payload}"
    try:
        res = requests.get(test_url, timeout=5)
        if "malicious" in res.text:
            return "‚ö†Ô∏è Potenziale Remote File Inclusion rilevata!"
    except Exception as e:
        return f"‚ùå Errore durante test RFI: {e}!"
    return "‚úÖ Nessuna RFI rilevata."


def check_command_injection(url):
    payload = "test; ls"
    test_url = f"{url}?cmd={payload}"
    try:
        res = requests.get(test_url, timeout=5)
        if "bin" in res.text or "root" in res.text:
            return "‚ö†Ô∏è Potenziale Command Injection rilevata!"
    except Exception as e:
        return f"‚ùå Errore durante test Command Injection: {e}!"
    return "‚úÖ Nessuna Command Injection rilevata."


def check_host_header_injection(url):
    try:
        headers = {"Host": "evil.com"}
        res = requests.get(url, headers=headers, timeout=5)
        if "evil.com" in res.text:
            return "‚ö†Ô∏è Potenziale Host Header Injection rilevata!"
    except Exception as e:
        return f"‚ùå Errore durante test Host Header Injection: {e}!"
    return "‚úÖ Nessuna Host Header Injection rilevata."


def check_xss(url):
    payload = "<script>alert('XSS')</script>"
    test_url = f"{url}?q={payload}"
    try:
        res = requests.get(test_url, timeout=5)
        if payload in res.text:
            return "‚ö†Ô∏è Potenziale XSS rilevato!"
    except Exception as e:
        return f"‚ùå Errore durante test XSS: {e}!"
    return "‚úÖ Nessuna XSS rilevata."


def check_csrf(url):
    try:
        res = requests.get(url, timeout=5)
        if "csrf" not in res.text.lower() and "token" not in res.text.lower():
            return "‚ö†Ô∏è Potenziale vulnerabilit√† CSRF (assenza token anti-CSRF)"
    except Exception as e:
        return f"‚ùå Errore durante test CSRF: {e}!"
    return "‚úÖ Meccanismi anti-CSRF rilevati."


def check_open_redirect(url):
    payload = "https://example.com"
    test_url = f"{url}?redirect={payload}"
    try:
        res = requests.get(test_url, allow_redirects=False, timeout=5)
        if res.status_code in (301, 302) and "Location" in res.headers:
            location = res.headers["Location"]
            if "example.com" in location:
                return "‚ö†Ô∏è Potenziale Open Redirect rilevato!"
    except Exception as e:
        return f"‚ùå Errore durante test Open Redirect: {e}!"
    return "‚úÖ Nessun Open Redirect rilevato."


def check_insecure_cookies(url):
    try:
        res = requests.get(url, timeout=5)
        for cookie in res.cookies:
            if not cookie.secure or "httponly" not in cookie._rest:
                return "‚ö†Ô∏è Cookie insicuri trovati (manca Secure/HttpOnly)"
    except Exception as e:
        return f"‚ùå Errore durante test Cookie: {e}!"
    return "‚úÖ Cookie sicuri rilevati."


def log_result(url, results):
    now = datetime.now()
    filename = now.strftime("logs/vulnerability_%Y-%m-%d_%H-%M.txt")
    os.makedirs("logs", exist_ok=True)
    with open(filename, "w", encoding="utf-8") as f:
        f.write(f"[{now}] Risultati per {url}:\n")
        f.write("\n".join(results))
        f.write("\n")


def normalize_url(url: str) -> str:
    parsed = urlparse(url)
    if not parsed.scheme:
        url = "http://" + url
    return url


async def send_daily_report(application: Application, chat_id: int):
    today = datetime.now().strftime("%Y-%m-%d")
    files = glob.glob(f"logs/vulnerability_{today}_*.txt")    
    if not files:
        await application.bot.send_message(chat_id=chat_id, text="üõ°Ô∏è Nessun test vulnerabilit√† effettuato oggi.")
        return
    report = f"üõ°Ô∏è Report vulnerabilit√† giornaliero ({today}):\n\n"
    for file in files:
        with open(file, "r", encoding="utf-8") as f:
            report += f.read() + "\n\n"
    if len(report) > 4000:
        with open(f"logs/report_{today}.txt", "w", encoding="utf-8") as f:
            f.write(report)
        with open(f"logs/report_{today}.txt", "rb") as f:
            await application.bot.send_document(chat_id=chat_id, document=f)
    else:
        await application.bot.send_message(chat_id=chat_id, text=report)


def start_scheduler(application: Application, chat_id: int):
    scheduler = AsyncIOScheduler()
    scheduler.add_job(send_daily_report, 'cron', hour=0, minute=0, args=[application, chat_id])
    scheduler.start()


async def vulnerability_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    print(f"Comando /vulnerability lanciato")
    user = update.effective_user
    msg = update.effective_message

    if not context.args:
        if msg:
            await msg.reply_text("‚ö†Ô∏è Usa: /vulnerability <url>")
        else:
            print("‚ùå Errore: nessun messaggio su cui rispondere!")
        append_log_entry(
            "vulnerability",
            user.id,
            user.username or "",
            "url=N/D",
            "Argomento mancante nel comando"
        )
        return

    url = normalize_url(context.args[0])
    append_log_entry(
        "vulnerability",
        user.id,
        user.username or "",
        f"url={url}",
        "Avvio scansione vulnerabilit√†"
    )

    try:
        results = [
            check_sql_injection(url),
            check_directory_traversal(url),
            check_lfi(url),
            check_rfi(url),
            check_command_injection(url),
            check_host_header_injection(url),
            check_xss(url),
            check_csrf(url),
            check_open_redirect(url),
            check_insecure_cookies(url),
        ]    
        vulnerabilities_to_deep = []
        for r in results:
            if "SQL Injection" in r:
                vulnerabilities_to_deep.append(("SQL Injection", "sql_injection"))
            if "Open Redirect" in r:
                vulnerabilities_to_deep.append(("Open Redirect", "open_redirect"))
            if "Command Injection" in r:
                vulnerabilities_to_deep.append(("Command Injection", "command_injection"))
            if "Host Header Injection" in r:
                vulnerabilities_to_deep.append(("Host Header Injection", "host_header_injection"))            

        summary = "Nessuna vulnerabilit√† rilevata" if all("non trovata" in r.lower() or "non vulnerabile" in r.lower() for r in results) else "Possibili vulnerabilit√† rilevate"

        await msg.reply_text("üõ°Ô∏è Risultati test vulnerabilit√†:\n\n" + "\n".join(results))
        append_log_entry(
            "vulnerability",
            user.id,
            user.username or "",
            f"url={url}",
            summary
        )

        if vulnerabilities_to_deep:
            reply_markup = InlineKeyboardMarkup([
                [InlineKeyboardButton(name, callback_data=callback)]
                for name, callback in vulnerabilities_to_deep
            ])
            await msg.reply_text(
                "Se vuoi approfondire, scegli una vulnerabilit√†:",
                reply_markup=reply_markup
            )
    except Exception as e:
        await msg.reply_text(f"‚ùå Errore durante la scansione: {str(e)}")
        append_log_entry(
            "vulnerability",
            user.id,
            user.username or "",
            f"url={url}",
            f"Errore: {str(e)}"
        )
